# Basic Password Security

At some point in your career, you may be asked to develop a system to authenticate users with a username and a password.
That seems like a pretty innocent request, right?

## Welcome to Cyber Security! Prepare to have your whole career ruined in 3... 2...

1...
I'm not joking.
There aren't many innocent mistakes you could make as a software engineer which would actually ruin your career,
but mis-managing users' passwords can *definitely, 100%* be a **career-ending mistake**.
Data-breaches, and loss of users' personally identifying information is no joke,
and you absolutely do **NOT** want to be the one responsible when that happens (and it WILL happen).

### "But I don't want to lose my job! :'("

Then fear not, because the solution here is actually very simple:
whenever you need to authenticate a user's identity, just make someone else do it for you
(that way, when something inevitably goes wrong, that other person will be the one to get fired instead of you).
The most common way to accomplish this is through a protocol called *"OAuth"*,
which we'll cover in much more detail in the [next article](./6c.%20OAuth.md).

But wait!
Before you go off and pick some other company to protect your application through OAuth,
you need to understand a little bit more about the things that company will actually do behind the scenes in order to keep your
users' passwords safe from prying eyes.
Ultimately, this comes down to two things: password processing, and password policy.

## Password Processing

You should always avoid knowing users' passwords.
The reason for this is simple:
if you don't know what their password is, then neither will anybody who hacks into your application.
But this leaves us with another problem:
if you don't know their password, then how will you know whether the password they use to sign in is right or wrong?

The solution is something called "password hashing".

You've probably heard of "hashing" before: it's the magical, mathematical mumbo jumbo that makes hash-maps work.
If you've read [Chapter 1](../âœ…%20%20%20%20%2001.%20Version%20Control/1a.%20Version%20Control.md),
then you'll also know that hashing plays a big role in how Git keeps track of all of your code.
Although both of these examples do make use of hashing, password hashing is done very differently.

For those of you who aren't super familiar with hashing, you can think about hashing kind of like encryption,
except hashing only works in one direction.
Once you hash something, there's no way to de-hash it (ideally).

![Hashing Algorithms](../FILES/auth/basicHashing.svg)

This way, as long as you keep track of the hash, you can verify a user's identity without needing to know their password.
Of course, this only works if you use a strong, *cryptographic* hashing algorithm.

