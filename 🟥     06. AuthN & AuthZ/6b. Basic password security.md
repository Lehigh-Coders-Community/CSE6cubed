# Basic Password Security

At some point in your career, you may be asked to develop a system to authenticate users with a username and a password.
That seems like a pretty innocent request, right?

## Welcome to Cyber Security! Prepare to have your whole career ruined in 3... 2...

1...
I'm not joking.
There aren't many innocent mistakes you could make as a software engineer which would actually ruin your career,
but mis-managing users' passwords can *definitely, 100%* be a **career-ending mistake**.
Data-breaches, and loss of users' personally identifying information is no joke,
and you absolutely do **NOT** want to be the one responsible when that happens (and it WILL happen).

### "But I don't want to lose my job! :'("

Then fear not, because the solution here is actually very simple:
whenever you need to authenticate a user's identity, just make someone else do it for you
(that way, when something inevitably goes wrong, that other person will be the one to get fired instead of you).
The most common way to accomplish this is through a protocol called *"OAuth"*,
which we'll cover in much more detail in the [next article](./6c.%20OAuth.md).

But wait!
Before you go off and pick some other company to protect your application through OAuth,
you need to understand a little bit more about the things that company will actually do behind the scenes in order to keep your
users' passwords safe from prying eyes.
Ultimately, this comes down to two things: password processing, and password policy.

## Password Processing

You should always avoid knowing users' passwords.
The reason for this is simple:
if you don't know what their password is, then neither will anybody who hacks into your application.
But this leaves us with another problem:
if you don't know their password, then how will you know whether the password they use to sign in is right or wrong?

The solution is something called "password hashing".

You've probably heard of "hashing" before: it's the magical, mathematical mumbo jumbo that makes hash-maps work.
If you've read [Chapter 1](../âœ…%20%20%20%20%2001.%20Version%20Control/1a.%20Version%20Control.md),
then you'll also know that hashing plays a big role in how Git keeps track of all of your code.
Although both of these examples do make use of hashing, password hashing is done very differently.

For those of you who aren't super familiar with hashing, you can think about hashing kind of like encryption,
except hashing only works in one direction.
Once you hash something, there's no way to de-hash it (ideally).

![Hashing Algorithms](../FILES/auth/basicHashing.svg)

This way, as long as you keep track of the hash, you can verify a user's identity without needing to know their password.
Of course, this only works if you use a strong, *cryptographic* hashing algorithm.

### What Makes a Strong Hash?

There are a number of things you need to make sure to do in order to protect your users' passwords when using hashes:

1. **Salting**: Some passwords are more common than others.
	If a whole bunch of people use something dumb like "password123" as their password,
	then all of those people will have the same password hash.
	This may signal to an attacker that those people have a weak password which is very easy to break.
	To fix this, we can apply a random value called a "salt" to each password before hashing it.
	If each password has a different salt value, then the resulting hashes will not be the same,
	which will make each of them significantly more difficult to attack.
2. **Unpredictability**: If the result of a hashing algorithm can be easily predicted,
	then an attacker may not have to put as much effort into breaking it.
	The most secure hashing algorithms are extremely unpredictable,
	meaning that tiny changes to the input (like chaning "password123" to "password124")
	will result it hashes which look completely different from each other
	(like the output from the example above).
3. **Slower = Better**: It may seem counter-intuitive, but fast hashing algorithms are actually worse than slower ones.
	The faster your algorithm is, the less time it will take for an attacker to break it with brute force.
	As a result, cryptographic hashing algorithms are designed to be slow,
	and you'll often want to feed the resulting hashes back into the function several times for each password
	in order to make the process of generating those hashes as slow as possible
	(without making them so slow that they become unusable).

That's a lot of text, so here's all of that information again, summed-up in a nice graphic:

![Hash Security](../FILES/auth/secureHashing.svg)

Personally, I prefer to use an algorithm called *PBKDF2* when hashing passwords, with *SHA512* as the inner hash function.
I also always salt the input passwords, and I usually set *PBKDF2*'s repetition value to repeatedly hash each password
up to *3 million times* per hash.
These settings can go a very long way toward keeping your users' passwords secure from any would-be attackers.

Of course, by the time you read this, both of those functions may be *long* out of date,
so it's always important to do your research about password hashing functions, and stay up-to-date on which ones are and aren't
safe for use.

