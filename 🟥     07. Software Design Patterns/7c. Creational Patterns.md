# Creational Software Design Patterns

## Abstract Factory Pattern:
This pattern is all about **providing an interface for creating families of related or depedendent objects, without specifying their concrete classes**

A diagram of how this works can be found below:
![Abstract Factory Design Diagram](../FILES/software-design-patterns/abstract_factory.png)

Visit [this link](https://en.wikipedia.org/wiki/Abstract_factory_pattern#Python_example) for a code sample describing the above diagram.

## Singleton Pattern:
This pattern is all about **restricting the instantiation of a class to have only a single instance across the piece of software.**

It is important to note that the Singleton **introduces global state into the application** because it provides global access to this single instance for all concrete classes. This could sometimes lead to unecessary restrictions in cases where a sole instance is not really required, and could make Unit Testing more difficult.

### A Simple Java Implementation:
```java
public final class Singleton {

    private static final Singleton INSTANCE = new Singleton();

    private Singleton() {}

    public static Singleton getInstance() {
        return INSTANCE;
    }
}
```

## Builder Pattern:
This pattern is used to **separate the construction of a complex object from its representation.** This allows the same construction process to create different representations of an object.

This can be seen in the following diagram:
![Builder Pattern UML Diagram](../FILES/software-design-patterns/builder_pattern.jpg)

## Factory Pattern
This pattern is about **defining an interface for creating an object, but lets subclasses decide which concrete class to actually instantiate.** 

Object creation can lead to significant duplication of code, require information that is not acessible to the composing object, or deal with information that does not really concern the composing object.

An example of how this could be:

Given a class `Vehicle` that has a member `Motor` of interface `IMotor`, but **no concrete type of `Motor` defined in advance.**

This `Motor` can either be constructed by telling the `Vehicle` constructor to use an `ElectricMotor` or a `GasolineMotor`.

The `Vehicle` constructor code then calls a `Motor` factory method, to create the desired `Motor` that complies with the `IMotor` interface.

# More information on Creational Patterns
If you would like to learn more about the different kinds of Creational Patterns, you can start with this list:

[Creational Patterns](https://en.wikipedia.org/wiki/Software_design_pattern#Creational_patterns)

## Where to Next?
- [Next: Structural Patterns](./7d.%20Structural%20Patterns.md)
- [Back: Types of Software Design Patterns](./7b.%20Types%20of%20Software%20Design%20Patterns.md)
- [TOP: CSE6cubed](../README.md)